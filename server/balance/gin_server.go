package balance

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
	"time"

	_ "userbalance/docs"

	// docs folder path generated by swag init

	"github.com/gin-gonic/gin"
	ginSwagger "github.com/swaggo/gin-swagger"
	"github.com/swaggo/gin-swagger/swaggerFiles"
)

type ServerGin struct {
	userStorage         IUserStorage
	transactionsStorage ItransactionsStorage
	router              *gin.Engine
	host                string
	port                int
}

type RequestMoveMoney struct {
	UserId int     `json:"userid"`
	Money  float64 `json:"money"`
}

type RequestUser struct {
	Username string `json:"username"`
	Password string `json:"paswword"`
}

type TransferMoney struct {
	UserIdTo   uint    `json:"UserIdTo"`
	UserIdFrom uint    `json:"UserIdFrom"`
	Money      float64 `json:"Money"`
}

type RequestError struct {
	Error string `json:"error"`
}

type IChatServer interface {
	Use(userStorage IUserStorage, transactionsStorage ItransactionsStorage)
	Run()
}

func NewServerGin(host string, port int) *ServerGin {
	ServerGin := new(ServerGin)
	ServerGin.host = host
	ServerGin.port = port

	return ServerGin
}

func (serverGin *ServerGin) Use(userStorage IUserStorage, transactionsStorage ItransactionsStorage) {

	serverGin.router = gin.Default()

	serverGin.transactionsStorage = transactionsStorage
	serverGin.userStorage = userStorage
	// Конфигурируем все эндпоинты
	serverGin.router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	serverGin.router.GET("/api/health", heathHandler())
	serverGin.router.POST("/api/user", userHandler(serverGin.userStorage))
	serverGin.router.POST("/api/money", getMoneyUserHadler(serverGin.userStorage))
	serverGin.router.POST("/api/money?currency=USD", getMoneyUserHadler(serverGin.userStorage))
	serverGin.router.POST("/api/add", addMoneyHandler(serverGin.transactionsStorage))
	serverGin.router.POST("/api/reduce", reduceMoneyHandler(serverGin.transactionsStorage))
	serverGin.router.POST("/api/transfer", transferMoneyHandler(serverGin.transactionsStorage))
	// serverGin.router.GET("https://freecurrencyapi.net/api/v2/latest?apikey=d53f1180-94a8-11ec-992b-13a8f6f1bdf9&base_currency=USD",exchangeHandler())

}

func (serverGin *ServerGin) Run() error {
	if serverGin.router == nil {
		return fmt.Errorf("gin не сконфигурирован %v", serverGin.router)
	}

	return serverGin.router.Run(":8080")
}

// heathHandler godoc
// @Summary Show the status of server.
// @Description get the status of server.
// @Tags Get Info
// @Accept json
// @Produce json
// @Router /api/health [get]
func heathHandler() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		ctx.IndentedJSON(http.StatusOK, gin.H{
			"success": true,
			"time":    time.Now().Format(time.RFC3339),
		})

	}
}

// userHandler godoc
// @tags Auth
// @Summary userHandler
// @Description Регистрация пользователя
// @Produce json
// @Param user body RequestUser true "RequestUser"
// @Router /api/user [post]
func userHandler(userStorage IUserStorage) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		requestUser := new(RequestUser)

		statusCode, ctx2, checkBadRequest := validateClientRequest(ctx, requestUser)

		if !checkBadRequest {
			ctx.IndentedJSON(statusCode, ctx2)
			return
		}

		if !validatenUserName(requestUser.Username) {
			ctx.IndentedJSON(http.StatusForbidden, gin.H{"error": "Invalid Username"})
			return
		}

		if !validatePassword(requestUser.Password) {
			ctx.IndentedJSON(http.StatusForbidden, gin.H{"error": "Invalid Password"})
			return
		}
		userMode, err := userStorage.GetByName(requestUser.Username)
		if err == nil {
			ctx.IndentedJSON(http.StatusUnauthorized, gin.H{"error": "Пользователь существует в базе"})
			return
		}
		userMode, err = userStorage.Create(requestUser.Username, requestUser.Password)
		if err != nil {
			ctx.IndentedJSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
			return
		}
		usd := ctx.Param("currency")
		if usd == "USD" {
			rate := exchangeHandler()
			userMode.Money = userMode.Money / rate
			ctx.IndentedJSON(http.StatusCreated, gin.H{"username": userMode.Username, "money": userMode.Money})
		}
		ctx.IndentedJSON(http.StatusCreated, gin.H{"username": userMode.Username, "money": userMode.Money})
	}

}

// addMoneyHandler godoc
// @tags Balance
// @Summary addMoneyHandler
// @Description Зачислить средства
// @Produce json
// @Param user body RequestMoveMoney true "RequestUser"
// @Router /api/add [post]
func addMoneyHandler(transactionsStorage ItransactionsStorage) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		requestUser := new(RequestMoveMoney)

		statusCode, ctx2, checkBadRequest := validateClientRequest(ctx, requestUser)

		if !checkBadRequest {
			ctx.IndentedJSON(statusCode, ctx2)
			return
		}

		_, err := transactionsStorage.AddMoney(uint(requestUser.UserId), requestUser.Money)
		if err != nil {
			ctx.IndentedJSON(http.StatusForbidden, err.Error())
			return
		}
		ctx.IndentedJSON(http.StatusOK, gin.H{"userId": requestUser.UserId, "money": requestUser.Money})
	}
}

// reduceMoneyHandler godoc
// @tags Balance
// @Summary reduceMoneyHandler
// @Description Списать денежные средства
// @Produce json
// @Param user body RequestMoveMoney true "User Data"
// @Router /api/reduce [post]
func reduceMoneyHandler(transactionsStorage ItransactionsStorage) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		requestUser := new(RequestMoveMoney)

		statusCode, ctx2, checkBadRequest := validateClientRequest(ctx, requestUser)

		if !checkBadRequest {
			ctx.IndentedJSON(statusCode, ctx2)
			return
		}

		_, err := transactionsStorage.WriteOffMoney(uint(requestUser.UserId), requestUser.Money)
		if err != nil {
			ctx.IndentedJSON(http.StatusForbidden, err.Error())
			return
		}
		ctx.IndentedJSON(http.StatusOK, gin.H{"userId": requestUser.UserId, "money": requestUser.Money})
	}
}

// transferMoneyHandler godoc
// @tags Balance
// @Summary transferMoneyHandler
// @Description Перевести деньги от пользователя к пользователю
// @Produce json
// @Param TransactionsModel body TransferMoney true "User Data"
// @Router /api/transfer [post]
func transferMoneyHandler(transactionsStorage ItransactionsStorage) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		requestUser := new(TransferMoney)

		statusCode, ctx2, checkBadRequest := validateClientRequest(ctx, requestUser)

		if !checkBadRequest {
			ctx.IndentedJSON(statusCode, ctx2)
			return
		}

		_, err := transactionsStorage.TransferMoney(requestUser.UserIdFrom, requestUser.UserIdTo, requestUser.Money)
		if err != nil {
			ctx.IndentedJSON(http.StatusForbidden, err.Error())
			return
		}
		ctx.IndentedJSON(http.StatusOK, gin.H{"userId": requestUser.UserIdFrom, "money": requestUser.Money})
	}
}

// getMoneyUserHadler godoc
// @tags Balance
// @Summary getMoneyUserHadler
// @Description Получить данные о балансе
// @Produce json
// @Param user body RequestUser true "User Data"
// @Router /api/money [post]
func getMoneyUserHadler(userStorage IUserStorage) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		requestUser := new(RequestUser)

		statusCode, ctx2, checkBadRequest := validateClientRequest(ctx, requestUser)

		if !checkBadRequest {
			ctx.IndentedJSON(statusCode, ctx2)
			return
		}

		userModel, err := userStorage.GetByName(requestUser.Username)
		if err != nil {
			ctx.IndentedJSON(http.StatusForbidden, err.Error())
			return
		}
		ctx.IndentedJSON(http.StatusOK, userModel)
	}
}

func exchangeHandler() float64 {
	resp, err := http.Get("https://freecurrencyapi.net/api/v2/latest?apikey=d53f1180-94a8-11ec-992b-13a8f6f1bdf9&base_currency=USD")
	if err != nil {
		log.Fatalln(err)
	}
	var dd interface{}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	log.Println(string(body))
	json.Unmarshal(body, dd)
	return 80
}

func validatenUserName(userName string) bool {
	var validPath = regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString
	return validPath(userName) && len(userName) < 16
}

func validatePassword(password string) bool {
	return len(password) < 32
}

func validateClientRequest(ctx *gin.Context, requestData interface{}) (int, interface{}, bool) {

	err := ctx.BindJSON(&requestData)
	if err != nil {

		return http.StatusBadRequest, gin.H{"error": "Не содержит поля в запросе"}, false
	}
	return http.StatusOK, gin.H{"error": ""}, true
}
