package balance

import (
	"fmt"
	"net/http"
	"regexp"
	"time"

	// docs folder path generated by swag init

	"github.com/gin-gonic/gin"
	ginSwagger "github.com/swaggo/gin-swagger"
	"github.com/swaggo/gin-swagger/swaggerFiles"
)

type ServerGin struct {
	userStorage         IUserStorage
	transactionsStorage ItransactionsStorage
	router              *gin.Engine
	host                string
	port                int
	maxLastMessages     uint
}

type RequestUser struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type RequestMessage struct {
	ApiToken string `json:"api_token"`
	Text     string `json:"text"`
}
type RequestMessages struct {
	Messages []struct {
		Id         uint      `json:"id"`
		MemberName string    `json:"member_name"`
		Text       string    `json:"text"`
		Time       time.Time `json:"time"`
	} `json:"messages"`
}
type RequestError struct {
	Error string `json:"error"`
}

type IChatServer interface {
	Use(userStorage IUserStorage, transactionsStorage ItransactionsStorage)
	Run()
}

func NewChatServerGin(host string, port int, maxLastMessages uint) *ServerGin {
	chatServerGin := new(ServerGin)
	chatServerGin.host = host
	chatServerGin.port = port
	chatServerGin.maxLastMessages = maxLastMessages
	return chatServerGin
}

func (serverGin *ServerGin) Use(userStorage IUserStorage, transactionsStorage ItransactionsStorage) {

	serverGin.router = gin.Default()
	serverGin.transactionsStorage = transactionsStorage
	serverGin.userStorage = userStorage
	// Конфигурируем все эндпоинты
	serverGin.router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	serverGin.router.POST("/api/user", userHandler(serverGin.userStorage))
	// serverGin.router.POST("/api/messages", messagesHandler(serverGin.transactionsStorage, serverGin.userStorage, serverGin.maxLastMessages))
	serverGin.router.GET("/api/health", heathHandler())
}

func (serverGin *ServerGin) Run() error {
	if serverGin.router == nil {
		return fmt.Errorf("gin не сконфигурирован %v", serverGin.router)
	}
	return serverGin.router.Run()
}

// heathHandler godoc
// @Summary Show the status of server.
// @Description get the status of server.
// @Tags Get Info
// @Accept json
// @Produce json
// @Router /api/health [get]
func heathHandler() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		ctx.IndentedJSON(http.StatusOK, gin.H{
			"success": true,
			"time":    time.Now().Format(time.RFC3339),
		})

	}
}

// userHandler godoc
// @tags Auth
// @Summary userHandler
// @Description Регистрация пользователя
// @Produce json
// @Param user body RequestUser true "User Data"
// @Router /api/user [post]
func userHandler(userStorage IUserStorage) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		requestUser := new(RequestUser)

		statusCode, ctx2, checkBadRequest := validateClientRequest(ctx, requestUser)

		if !checkBadRequest {
			ctx.IndentedJSON(statusCode, ctx2)
			return
		}

		if !validatenUserName(requestUser.Username) {
			ctx.IndentedJSON(http.StatusForbidden, gin.H{"error": "Invalid Username"})
			return
		}

		if !validatePassword(requestUser.Password) {
			ctx.IndentedJSON(http.StatusForbidden, gin.H{"error": "Invalid Password"})
			return
		}
		userMode, err := userStorage.GetByName(requestUser.Username)
		if err == nil {
			ctx.IndentedJSON(http.StatusUnauthorized, gin.H{"error": "Пользователь существует в базе"})
			return
		}
		userMode, err = userStorage.Create(requestUser.Username, requestUser.Password)
		if err != nil {
			ctx.IndentedJSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
			return
		}

		ctx.IndentedJSON(http.StatusCreated, gin.H{"username": userMode.Username})
	}

}

// messagesHandler godoc
// @tags Get Info
// @Summary messagesHandler
// @Description Получить список сообщений
// @Produce json
// @Param user body RequestApiToken true "User ApiToken"
// @Router /api/messages [post]
// func messagesHandler(transactionsStorage ItransactionsStorage, userStorage IUserStorage, maxLastMessages uint) gin.HandlerFunc {
// 	return func(ctx *gin.Context) {

// 		requestApiToken := new(RequestMessage)

// 		statusCode, ctx2, checkBadRequest := validateClientRequest(ctx, requestApiToken)
// 		if !checkBadRequest {
// 			ctx.IndentedJSON(statusCode, ctx2)
// 			return
// 		}

// 		messageModel, err := transactionsStorage.GetLast(maxLastMessages)
// 		if err != nil {
// 			type NewMessages struct {
// 				Messages []string `json:"messages"`
// 			}
// 			empty := make([]string, 0)
// 			emptyMembers := NewMessages{Messages: empty}
// 			ctx.IndentedJSON(http.StatusOK, emptyMembers)
// 			return
// 		}

// 		newMessages := new(RequestMessages)
// 		for _, u := range messageModel {
// 			userModel, _ := userStorage.GetById(u.UserId)
// 			newMessages.Messages = append(newMessages.Messages, struct {
// 				Id         uint      "json:\"id\""
// 				MemberName string    "json:\"member_name\""
// 				Text       string    "json:\"text\""
// 				Time       time.Time "json:\"time\""
// 			}{u.ID, userModel.Username, u.Text, u.Time})

// 		}
// 		ctx.IndentedJSON(http.StatusOK, newMessages)
// 	}
// }

func validatenUserName(userName string) bool {
	var validPath = regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString
	return validPath(userName) && len(userName) < 16
}

func validatePassword(password string) bool {
	return len(password) < 32
}

func checkUserPassword(userName string, password string, userStorage IUserStorage) bool {
	userModel, err := userStorage.GetByName(userName)
	return err == nil && userModel.PasswordHash == new(PasswordHasherSha1).CalculateHash(password)
}

func validateClientRequest(ctx *gin.Context, requestData interface{}) (int, interface{}, bool) {

	err := ctx.BindJSON(&requestData)
	if err != nil {

		return http.StatusBadRequest, gin.H{"error": "Не содержит поля в запросе"}, false
	}
	return http.StatusOK, gin.H{"error": ""}, true
}
